package pattern

import "fmt"

/*
	Реализовать паттерн «цепочка вызовов».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern
*/

// Приведём пример с калькулятором

// Создаём калькулятор
type Calculator struct {
	result int
}

// Методы для выполнения математических операций и возврата результата
func (c *Calculator) Add(x int) *Calculator {
	c.result += x
	return c
}

func (c *Calculator) Subtract(x int) *Calculator {
	c.result -= x
	return c
}

func (c *Calculator) Multiply(x int) *Calculator {
	c.result *= x
	return c
}

func (c *Calculator) Divide(x int) *Calculator {
	c.result /= x
	return c
}

func main() {
	// Создаем объект калькулятора и выполняем цепочку операций
	result := new(Calculator).
		Add(100).
		Subtract(50).
		Divide(2).
		Multiply(3).result

	fmt.Println("Результат: ", result)
}

/*
Паттерн "цепочка вызовов" представляет собой способ организации вызовов методов объекта в виде цепочки.
Каждый метод возвращает указатель на объект, что позволяет последовательно вызывать другие методы

Плюсы паттерна "цепочка вызовов":
1. Улучшает читаемость кода
2. Уменьшает использование временных переменных
3. Позволяет гибко настраивать порядок вызовов методов

Минусы паттерна "цепочка вызовов":
1. Может стать излишне сложным, если цепочка вызовов слишком длинная
2. Затрудняет отладку, потому что может быть затруднительно искать в глубокой цепочке вызовов
*/
